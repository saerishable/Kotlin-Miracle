### 프로퍼티와 매개변수의 차이

**프로퍼티**는 클래스의 속성을 나타내며, 클래스의 인스턴스와 연관된 데이터를 저장합니다. 프로퍼티는 클래스의 필드와 대응되며, 게터와 세터를 통해 값을 읽거나 쓸 수 있습니다.

**매개변수**는 함수나 생성자에서 사용되며, 함수 호출 시 전달되는 값을 받기 위해 사용합니다. 매개변수는 함수 내에서만 유효합니다.

### null을 허용하는 변수 타입 선언 시 기본값 설정

`?`를 사용하여 변수에 `null`을 허용할 수 있으나, 이후에 `= null`을 통해 기본값을 `null`로 설정해야 하는 것은 아닙니다. 예를 들어:

```kotlin
val age: Int? = null
```

여기서 `= null`을 빼고 다음과 같이 선언한다면, 객체를 생성할 때 반드시 값을 제공해야 합니다:

```kotlin
val age: Int?
```

기본값을 변수 선언 시에 설정하게 되면, 객체 생성 시 값을 제공하지 않아도 기본값을 사용할 수 있으며, 생성자를 통해 초기화해야 할 필요도 사라지게 됩니다.

자바에서는 다음과 같이 변수 이름 뒤에 기본값이 나옵니다:

```java
private String name = "test";
```

코틀린에서는 변수 타입을 이름 뒤에 사용합니다:

```kotlin
val name: String = "test"
```

사실상 변수 타입과 이름의 순서가 바뀌는 것만 빼면 초기값 설정은 동일합니다.

### 예시 코드 분석

```kotlin
val oldest = persons.maxByOrNull { it.age ?: 0 }
```

`maxByOrNull`은 컬렉션에서 최대값을 가진 요소를 찾으며, 만약 컬렉션이 비어 있으면 `null`을 반환합니다. 람다식은 각 `Person`의 `age` 프로퍼티를 기준으로 최대값을 찾으며, `age`가 `null`인 경우에는 `0`으로 대체하여 비교합니다. `maxByOrNull`은 본질적으로 람다식을 사용하여 컬렉션의 각 요소에 대한 기준을 제공하는 함수이기 때문에, 람다식을 사용하지 않고 `maxByOrNull`을 사용하는 것은 불가능합니다.

여기서 `it`은 람다식 내부에서 현재 요소를 참조하는데 사용됩니다. 즉, `persons` 리스트(컬렉션)의 `Person` 객체를 가리킵니다. 따라서 `it.age`는 현재 `Person` 객체의 `age` 프로퍼티를 참조합니다.

`?:`는 엘비스 연산자로, `null` 값이 발생할 수 있는 상황에서 기본값을 제공하는 데 사용됩니다.

## Kotlin의 주요 특성

### 타겟 플랫폼

서버사이드, 안드로이드, 혹은 어디든 자바가 사용되는 곳에서 Kotlin을 사용할 수 있습니다. `Kotlin/JS`를 통해 웹 페이지를 제작할 때도 Kotlin을 사용할 수 있습니다. 이는 Kotlin으로 만든 앱을 기반으로 웹 페이지를 만들고자 할 때 유용할 수 있습니다.

### 정적 타입 지정 언어

정적 타입 지정 언어란, 모든 프로그램 구성 요소의 타입을 컴파일 시점에 알 수 있고 프로그램 안에서 객체의 필드나 메서드를 사용할 때마다 컴파일러가 타입을 검증해준다는 뜻입니다.

동적 타입 지정 언어의 경우, 변수의 타입이 런타임에 결정됩니다. 즉, 변수 선언 시 명시적으로 지정되는 것이 아니라 변수에 할당되는 값에 따라 타입이 결정된다는 것입니다. (예: 파이썬, 자바스크립트 등)

#### 장점
- 유연성, 간결함, 빠른 프로토타이핑
#### 단점
- 타입 오류 가능성, 디버깅 어려움, 성능 문제

Kotlin은 타입 추론을 지원하기 때문에 변수 선언 시 타입을 생략할 수 있습니다. 컴파일러가 자동으로 변수의 타입을 결정합니다. `Any` 타입을 사용하면 동적 타입을 사용할 수 있습니다.

> 컴파일이 완료된 후, 프로그램이 실행되는 동안 발생하는 오류를 런타임 오류라고 합니다. 런타임 오류는 프로그램이 정상적으로 컴파일되고 실행을 시작한 이후에 발생합니다. 이러한 오류는 실행 시 특정 조건이나 입력에 의해 트리거될 수 있습니다. 예를 들어 Null Pointer Exception 에러가 런타임 오류의 예시입니다. 파이썬의 경우 타입을 동적으로 결정하기 때문에, 만약 숫자를 문자열로 나누려고 한다면 TypeError가 발생합니다.

Kotlin의 정적 타입 시스템 덕분에 많은 타입 관련 오류를 컴파일 타임에 발견할 수 있습니다. 단, 이는 타입 오류가 전혀 발생하지 않는다는 의미는 아닙니다. NullPointerException과 같은 예외는 여전히 발생할 수 있습니다.

### 정적 타입 지정 언어의 장점

- **성능**: 실행 시점에 어떤 메서드를 호출할지 알아내는 과정이 필요 없으므로 메서드 호출이 더 빠릅니다. (정적 타입 지정 언어에서는 컴파일 타임에 메서드 호출이 결정되기 때문에)
- **신뢰성**: 컴파일러가 프로그램의 정확성을 검증하기 때문에 실행 시 프로그램이 오류로 중단될 가능성이 더 적어집니다.
- **유지보수성**: 코드에서 다루는 객체가 어떤 타입에 속하는지 알 수 있기 때문에 처음 보는 코드를 다룰 때 더 쉽습니다.
- **도구 지원**: 정적 타입 지정을 통해 더 안전하게 리팩토링할 수 있고, 도구는 더 정확한 코드 완성 기능을 제공할 수 있습니다.

Kotlin의 타입 추론은 런타임 시점에 추론하는 것이 아니라 컴파일 시점에 추론합니다. (중요!)

Kotlin의 타입 시스템에서 중요한 새로운 개념 중 하나는 Nullable 타입 지원입니다. 이는 잠재적인 NullPointerException을 컴파일 타임에 감지하게 해줍니다. 또한 Kotlin은 함수 타입을 지원합니다.

### 함수형 프로그래밍과 객체지향 프로그래밍

함수형 프로그래밍은 프로그래밍 패러다임 중 하나로, 프로그램을 함수의 조합으로 구성하는 방식을 강조합니다. 함수를 값으로 다루거나, 다른 함수의 인자로 전달하고, 함수에서 반환할 수 있습니다. 이 패러다임은 수학적 함수의 개념에 기초하여, 불변성과 순수함수를 중시합니다.

#### 함수형 프로그래밍의 핵심 개념

- **일급 시민(first-class) 함수**: 함수를 일반 값처럼 다룰 수 있습니다.
  - 함수를 변수에 저장
  - 함수를 인자로 다른 함수에 전달
  - 함수에서 새로운 함수를 만들어서 반환
- **불변성**: 함수형 프로그래밍에서는 불변 객체를 사용하여 프로그램을 작성합니다.
- **부수효과 없음**: 입력이 같으면 항상 같은 출력이 나오는 순수 함수를 사용합니다.
  - 함수 외부의 상태나 변수를 변경하지 않습니다.
  - 함수 외부나 다른 바깥 환경과 상호작용하지 않는 순수 함수를 사용합니다.

> Q. 함수 외부의 상태나 변수를 변경한다는 것은 어떤 의미인가?
> 함수 외부의 상태나 변수를 변경한다는 것은 함수 내부에서 전역 변수나 함수 외부에 정의된 객체의 상태를 변경하거나, I/O 작업을 수행하는 것을 의미합니다.
> - 전역 변수 값 변경
> - 객체의 상태 변경 (외부의 데이터 클래스를 인수로 받아서 객체의 상태를 변경하는 경우)
> 함수의 실행이 외부 상태에 영향을 끼친다는 것은 **부작용(Side-effect)**을 일으킨다는 것을 의미합니다.

#### 함수형 프로그래밍의 이점

- **간결성**: 함수를 값처럼 활용하므로 더 강력한 추상화를 가능하게 합니다.
  - 함수를 값처럼 사용하므로 코드를 더 모듈화하고, 중복을 줄임으로써 추상화 수준을 높일 수 있습니다.
  - 공통 부분을 따로 함수로 뽑아내고 서로 다른 세부사항을 인자로 전달합니다. 인자 자체도 함수가 될 수 있습니다.
- **다중 스레드에서 안전**: 불변 데이터 구조를 사용하기 때문에 여러 스레드가 동시에 읽고 쓰는 상황에서도 상태 변화가 일어나지 않아 데이터 무결성을 보장할 수 있습니다.
  - 코틀린에서는 리스트, 셋 등에 대해 불변 데이터 구조와 가변 데이터 구조 둘 다 지원합니다.
- **테스트하기 쉽다**: 순수 함수는 준비 코드 없이 독립적으로 테스트할 수 있습니다.
  - 외부 상태에 상관 없기 때문에 해당 함수와 입력 값만 있다면 테스트가 가능하며, 전역 상태도 신경 쓸 필요가 없습니다.

> 함수형 프로그래밍은 순수 함수를 많이 사용하는 것을 권장하지만, 현실적인 프로그램에서는 때때로 부작용을 일으키는 함수가 필요합니다. 따라서 아예 사용하지 않는 것이라기보다는 가능한 한 부작용을 일으키는 코드를 최소화하고, 이러한 부작용을 관리하는 방법을 설계하는 것이 목표입니다.

###

 Kotlin의 빌더 패턴

빌더 패턴은 객체를 생성하는 과정을 단계별로 구성할 수 있게 해주는 생성 패턴의 하나입니다. 복잡한 객체를 생성할 때 생성자 또는 정적 팩토리 메서드의 사용으로 인한 복잡성을 줄이고, 코드의 가독성을 높이기 위해 사용합니다.

- **빌더 패턴이란**: 객체의 생성 과정을 캡슐화하여, 객체의 생성과정을 단계별로 진행할 수 있도록 해주는 디자인 패턴 중 하나입니다.
- 주로 복잡한 객체를 생성할 때 사용하며, 객체의 생성과정에서 가독성을 높이고 오류 가능성을 줄이는 데 유용합니다.

#### 빌더 패턴의 구성요소

1. **Builder 인터페이스**: 객체를 생성하기 위한 단계들을 정의합니다.
2. **ConcreteBuilder 클래스**: Builder 인터페이스를 구현하여 실제 객체 생성 과정을 수행합니다.
3. **Director 클래스**: Builder 객체를 이용하여 최종 객체를 생성합니다.
4. **Product 클래스**: 생성될 복잡한 객체를 나타냅니다.

인터페이스는 단계를 정의하고, ConcreteBuilder에서 실제로 구현하며, Director 클래스에서 ConcreteBuilder에서 구현해둔 것을 이용하여 최종 객체를 생성합니다. (Concrete 단계에서는 각 요소만 각자 구현)

### Kotlin DSL

Kotlin DSL을 사용하면 별도의 템플릿 언어나 쿼리 언어를 배우지 않고도 복잡한 작업을 쉽게 처리할 수 있습니다. 이를 통해 코드의 가독성과 유지보수성을 크게 향상시킬 수 있습니다. 코틀린은 자바와 완벽히 호환되기 때문에 코틀린으로 작성된 코드는 자바 런타임에서 원활하게 실행되며, 최신 Android 버전을 실행하지 않는 장치에서도 작동합니다. Kotlin의 성능은 자바 코드와 동일합니다. Kotlin 런타임은 비교적 작기 때문에 컴파일된 애플리케이션 패키지의 크기가 크게 증가하지 않습니다. Kotlin의 표준 라이브러리의 많은 함수는 람다를 인라인합니다. 람다 인라이닝은 새로운 객체 생성을 방지하고, 추가적인 가비지 컬렉션 중단이 발생하지 않도록 합니다. 이는 성능을 최적화하는 데 도움이 됩니다.

## 코틀린의 철학

### 실용성

실제 문제를 해결하기 위해 만들어진 실용적인 언어입니다. 프로그래밍 스타일에서 유연성을 추구하며 특정 프로그래밍 스타일이나 패러다임을 강요하지 않습니다. 도구 지원에 중점을 둡니다. 언어 기능이 도구 지원을 염두에 두고 설계되었습니다.

### 간결성

코드가 간단하고 간결할수록, 코드의 내용을 더 빨리 이해할 수 있습니다.

### 안전성

- **메모리 안전성**
- **타입 안전성**
- **NullPointerException 방지**
- **ClassCastException 방지**

자바에서는 타입 검사와 캐스팅을 별도로 수행해야 하지만, Kotlin에서는 이를 단일 연산으로 결합하여 검사 후 추가 캐스팅 없이 타입의 멤버에 접근할 수 있습니다.

### 상호운용성

- **기존 라이브러리 사용**
- **자바 애노테이션을 코틀린 클래스에 적용할 수 있음**
- **Kotlin 클래스와 메서드는 일반 Java 클래스와 메서드처럼 호출 가능**
- **자바 라이브러리의 최대 활용**

Kotlin은 자체 컬렉션 라이브러리를 가지고 있지 않습니다. 대신, Java 표준 라이브러리 클래스를 완전히 활용하고, 이를 확장하여 Kotlin에서 더 편리하게 사용할 수 있도록 추가 기능을 제공합니다.

## Summary

**1. Kotlin은 정적 타입 언어이며 타입 추론을 지원합니다.**

- **타입 안정성**: 코드의 정확성과 성능을 유지하면서도 소스 코드를 간결하게 유지할 수 있습니다.
- **타입 추론**: 변수의 타입을 명시적으로 선언하지 않아도 컴파일러가 타입을 추론할 수 있습니다.

**2. Kotlin은 객체 지향 프로그래밍과 함수형 프로그래밍을 모두 지원합니다.**

- **고차함수**: 일급 함수를 통해 더 높은 수준의 추상화를 가능하게 합니다.
- **불변 값**: 불변성을 지원하여 멀티스레드 개발과 테스트를 간단하게 만듭니다.

**3. 서버 사이드 애플리케이션에서 잘 작동합니다.**

- **Java 프레임워크 호환성**: 기존 Java 프레임워크를 완벽하게 지원하며, HTML 생성 및 퍼시스턴스와 같은 일반적인 작업을 위한 새로운 도구를 제공합니다.

**4. 안드로이드에서도 잘 작동합니다.**

**5. 무료 및 오픈소스입니다.**

**6. 실용적이고 안전하며 간결하고 상호 운용성이 뛰어납니다.**

- 자바에서는 클래스 정의, 생성자, getter, setter 메서드를 명시적으로 작성해야 하지만, Kotlin의 data class는 그보다 훨씬 간결합니다.

> 보일러 플레이트 코드란?
프로그램의 기본적인 기능을 수행하기 위해 반복적으로 작성해야 하는 코드. 클래스 정의(멤버 변수 정의)와 이에 접근하기 위한 getter와 setter 메서드, 예외처리에 대한 명시적인 작성.
